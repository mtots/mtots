"""
A simple game development library
"""
from media import Image
from media import Audio
from media import Canvas

# A collection of curated colors taken from PICO-8's palette.
# 16 offical colors + 16 unofficial colors for a total of 32.
final BLACK           = Color(   0,   0,   0, 255)
final DARK_BLUE       = Color(  29,  43,  83, 255)
final DARK_PURPLE     = Color( 126,  37,  83, 255)
final DARK_GREEN      = Color(   0, 135,  81, 255)
final BROWN           = Color( 171,  82,  54, 255)
final DARK_GREY       = Color(  95,  87,  79, 255)
final LIGHT_GREY      = Color( 194, 195, 199, 255)
final WHITE           = Color( 255, 241, 232, 255)
final RED             = Color( 255,   0,  77, 255)
final ORANGE          = Color( 255, 163,   0, 255)
final YELLOW          = Color( 255, 236,  39, 255)
final GREEN           = Color(   0, 228,  54, 255)
final BLUE            = Color(  41, 173, 255, 255)
final LAVENDER        = Color( 131, 118, 156, 255)
final PINK            = Color( 255, 119, 168, 255)
final LIGHT_PEACH     = Color( 255, 204, 170, 255)
final BROWNISH_BLACK  = Color(  41,  24,  20, 255)
final DARKER_BLUE     = Color(  17,  29,  53, 255)
final DARKER_PURPLE   = Color(  66,  33,  54, 255)
final BLUE_GREEN      = Color(  18,  83,  89, 255)
final DARK_BROWN      = Color( 116,  47,  41, 255)
final DARKER_GREY     = Color(  73,  51,  59, 255)
final MEDIUM_GREY     = Color( 162, 136, 121, 255)
final LIGHT_YELLOW    = Color( 243, 239, 125, 255)
final DARK_RED        = Color( 190,  18,  80, 255)
final DARK_ORANGE     = Color( 255, 108,  36, 255)
final LIME_GREEN      = Color( 168, 231,  46, 255)
final MEDIUM_GREEN    = Color(   0, 181,  67, 255)
final TRUE_BLUE       = Color(   6,  90, 181, 255)
final MAUVE           = Color( 117,  70, 101, 255)
final DARK_PEACH      = Color( 255, 110,  89, 255)
final PEACH           = Color( 255, 157, 129, 255)


final COLORS """
  List of PICO-8 colors in order PICO-8's palette order
""" = final[
  BLACK,
  DARK_BLUE,
  DARK_PURPLE,
  DARK_GREEN,
  BROWN,
  DARK_GREY,
  LIGHT_GREY,
  WHITE,
  RED,
  ORANGE,
  YELLOW,
  GREEN,
  BLUE,
  LAVENDER,
  PINK,
  LIGHT_PEACH,
  BROWNISH_BLACK,
  DARKER_BLUE,
  DARKER_PURPLE,
  BLUE_GREEN,
  DARK_BROWN,
  DARKER_GREY,
  MEDIUM_GREY,
  LIGHT_YELLOW,
  DARK_RED,
  DARK_ORANGE,
  LIME_GREEN,
  MEDIUM_GREEN,
  TRUE_BLUE,
  MAUVE,
  DARK_PEACH,
  PEACH,
]


final KEY """
Maps the name of each key to the scancode of the key for use with function `key()`
""" = final{
  "A":           0x04,
  "B":           0x05,
  "C":           0x06,
  "D":           0x07,
  "E":           0x08,
  "F":           0x09,
  "G":           0x0A,
  "H":           0x0B,
  "I":           0x0C,
  "J":           0x0D,
  "K":           0x0E,
  "L":           0x0F,
  "M":           0x10,
  "N":           0x11,
  "O":           0x12,
  "P":           0x13,
  "Q":           0x14,
  "R":           0x15,
  "S":           0x16,
  "T":           0x17,
  "U":           0x18,
  "V":           0x19,
  "W":           0x1A,
  "X":           0x1B,
  "Y":           0x1C,
  "Z":           0x1D,
  "1":           0x1E,
  "2":           0x1F,
  "3":           0x20,
  "4":           0x21,
  "5":           0x22,
  "6":           0x23,
  "7":           0x24,
  "8":           0x25,
  "9":           0x26,
  "0":           0x27,
  "ENTER":       0x28,
  "ESC":         0x29,
  "BACKSPACE":   0x2A,
  "TAB":         0x2B,
  "SPACE":       0x2C,
  "MINUS":       0x2D,
  "EQUAL":       0x2E,
  "LEFTBRACE":   0x2F,
  "RIGHTBRACE":  0x30,
  "BACKSLASH":   0x31,
  "HASHTILDE":   0x32,
  "SEMICOLON":   0x33,
  "APOSTROPHE":  0x34,
  "GRAVE":       0x35,
  "COMMA":       0x36,
  "DOT":         0x37,
  "SLASH":       0x38,
  "CAPSLOCK":    0x39,
  "F1":          0x3a,
  "F2":          0x3b,
  "F3":          0x3c,
  "F4":          0x3d,
  "F5":          0x3e,
  "F6":          0x3f,
  "F7":          0x40,
  "F8":          0x41,
  "F9":          0x42,
  "F10":         0x43,
  "F11":         0x44,
  "F12":         0x45,
  "SYSRQ":       0x46,
  "SCROLLLOCK":  0x47,
  "PAUSE":       0x48,
  "INSERT":      0x49,
  "HOME":        0x4A,
  "PAGEUP":      0x4B,
  "DELETE":      0x4C,
  "END":         0x4D,
  "PAGEDOWN":    0x4E,
  "RIGHT":       0x4F,
  "LEFT":        0x50,
  "DOWN":        0x51,
  "UP":          0x52,
  "NUMLOCK":     0x53,
  "KPSLASH":     0x54,
  "KPASTERISK":  0x55,
  "KPMINUS":     0x56,
  "KPPLUS":      0x57,
  "KPENTER":     0x58,
  "KP1":         0x59,
  "KP2":         0x5a,
  "KP3":         0x5b,
  "KP4":         0x5c,
  "KP5":         0x5d,
  "KP6":         0x5e,
  "KP7":         0x5f,
  "KP8":         0x60,
  "KP9":         0x61,
  "KP0":         0x62,
  "KPDOT":       0x63,
  "LEFTCTRL":    0xe0,
  "LEFTSHIFT":   0xe1,
  "LEFTALT":     0xe2,
  "LEFTMETA":    0xe3,
  "RIGHTCTRL":   0xe4,
  "RIGHTSHIFT":  0xe5,
  "RIGHTALT":    0xe6,
  "RIGHTMETA":   0xe7,
}


class Window:
  """
  A window for viewing the game.

  Currently, only one Window may be created per program.

  Once created, the Window's main loop will be queued to run
  when the __main__ module has finished.
  """

  static def defaultFPS() Int:
    """
    Gets the default frames per second.
    Always returns 30.
    """

  static def flagFIXEDFULLSCREEN() Int:
    """
    Flag to pass to the constructor to start the window in 'true' fullscreen mode.

    This will try to force the actual render resolution to match the requested
    resolution, but this is not always guaranteed. You should be able to
    check the `width` and `height` parameters of the resulting `Window` to
    verify the actual dimensions you got.

    Corresponds to `SDL_WINDOW_FULLSCREEN`.

    Compare with the `flagFULLSCREEN()` method.
    """

  static def flagFULLSCREEN() Int:
    """
    Flag to pass to the constructor to start the window in fullscreen mode.

    The requested window dimensions will be ignored and the window will go into
    fullscreen at the current desktop resolution.

    Corresponds to `SDL_WINDOW_FULLSCREEN_DESKTOP`.

    `SDL_WINDOW_FULLSCREEN_DESKTOP` is chosen instead of `SDL_WINDOW_FULLSCREEN`,
    because that is probably what you want. An old school fullscreen is rather
    disruptive. But if that is really what you want, you can use
    `flagFIXEDFULLSCREEN()`.
    """

  static def flagRESIZABLE() Int:
    """
    Flag to pass to the constructor to enable resizing.

    Corresponds to `SDL_WINDOW_RESIZABLE`
    """

  final transform Matrix """
    Transformation matrix to apply when rendering geometries.
    Used to control the camera.
  """

  final width Int """
    Width of the renderer output size.
    Due to high-dpi displays, you might end up with a rendering context
    that has more pixels than the window that contains it;
    as such, this value might not necessarily correspond to the actual
    pixel width of the window.
  """

  final height Int """
    Height of the renderer output size.
    Due to high-dpi displays, you might end up with a rendering context
    that has more pixels than the window that contains it;
    as such, this value might not necessarily correspond to the actual
    pixel height of the window.
  """

  final tick Int """
    The number of fully processed frames so far.
    Can be used to roughly gauge how many times `onUpdate` has been called.

    NOTE: Some consideration about whether we may encounter issues with
    retrieveing this value as a double (since all numbers in Mtots are doubles):
    The largest integer such that it and all smaller integers can be stored in
    IEEE 64-bit doubles without losing precision, seems to be ~2**53
    (See https://stackoverflow.com/a/1848762/)
    At 60 frames per second, this means that will will reach this many ticks
    in over 4000 years.
  """

  def __init__(
      title String = "",
      width Int = 0,
      height Int = 0,
      framesPerSecond Int = 30,
      flags Int = 0):
    ""

  def setTitle(title String) nil:
    """
    Sets the window's title
    """

  def setBackgroundColor(color Color) nil:
    """
    Sets the window's background color.

    The screen will be cleared with this color before call to `update`
    each frame.
    """

  def clear(color Color) nil:
    """
    Clear the screen with the given color
    """

  def onUpdate(update Function[Any]) nil:
    """
    Sets the update callback.

    The update callback is called 60 times per second
    right before each frame is presented to the screen.
    """

  def onClick(callback Function[ClickEvent, Any]) nil:
    """
    Sets the callback for when a mouse button or finger is pressed down.
    """

  def onClickUp(callback Function[ClickEvent, Any]) nil:
    """
    Sets the callback for when a mouse button or finger is released.
    """

  def onMotion(callback Function[MotionEvent, Any]) nil:
    """
    Sets the callback for when the mouse cursor or a touch moves across
    the screen
    """

  def getCanvas() Canvas:
    """
    Returns the `Canvas` currently associated with this `Window` (e.g. through
    a call to `newCanvas`).

    If there is no canvas `Canvas` associated with this `Window`, a new one is
    created with dmensions matching the current window.
    """

  def newCanvas(width Int=-1, height Int=-1) Canvas:
    """
    Returns a Canvas you can modify to draw on the window.

    If `width` or `height` is negative, they will default to the window
    width and window height in pixels respectively (more specifically
    the results of `SDL_GetRendererOutputSize`).

    Any canvas previously associated with this Window will no longer
    be associated with this Window.

    This canvas image will be redrawn on the window every
    frame before the update callback.

    This approach is slower than rendering with sprites and textures
    directly, but is easier and simpler to get something on the screen.
    """

  def newTexture(image Image, streaming Bool = false) Texture:
    """
    Creates a texture from an image that can be used to
    draw on this window.

    If `streaming` is set to true, the texture will hold a
    reference to the image, and the `update` method on the
    returned `Texture` will update the texture with the new
    state of `image`.
    """

  def setCamera(upperLeft Vector, lowerRight Vector) nil:
    """
    Update `this.transform` so that the the upper left corner of the
    screen corresponds to `upperLeft` and the lower right corner of the
    screen corresponds to `lowerRight`.

    Further, the camera will remain parallel to the original X and Y axes.
    """

  def newPolygon(
      points List[Vector],
      colors List[Color]?=nil,
      texture Texture?=nil,
      textureCoordinates List[Vector]?=nil) Geometry:
    """
    Create a new polygon `Geometry` with the given points.

    To create more general shapes, see the `newGeometry` method.

    If the `colors` list is provided, its length must be either 1 or `len(points)`
    and will assign colors to each vertex. If `len(colors)` is 1, every vertex
    will be assigned the same color.
    If `colors` is not provided or nil, the color
    of each vertex will be assumed to be `Color(255, 255, 255)`.

    If `texture` is provided, it will be used when rendering the polygon.
    Further, `textureCorodinates` will be used to determine the texture coordinates
    for each vertex. `textureCoordinates` should also match the length of `points`
    when provided.

    If `textureCoordinates` is omitted or nil, the first 4 points will be set to
    point to the four corners of the texture starting from the upper-left corner
    going clockwise.

    Texture coordinates are normalized - so each component should be a value between
    zero and one.
    """

  def newGeometry(vertexCount Int, indexCount Int) Geometry:
    """
    Create a new `Geometry` with the given number of vertices and indices.

    This low-level interface is useful when you want to render more than a single polygon
    in a single blit and you are willing to manually modify the geometry's
    attributes.
    """


class Texture:
  """
  A Texture is an Image that has been loaded into GPU memory
  """

  final width Int
  final height Int

  def blit(
      src Rect?,
      dst Rect?,
      angle Float=0,
      center Vector?=nil,
      flipX=false,
      flipY=false) nil:
    """
    Draws a portion of this texture to a portion of the render target.

    This function is basically a wrapper around `SDL_RenderCopyEx()`

    Parameters:
    * src - the rectangular region of this texture to draw or `nil` for the
      entire texture.
    * dst - the rectangular region of the render target to draw to, or
      `nil` for the entire rendering target; the texture will be
      stretched to fill the given rectangle
    * angle - angle (in radians) of how much to rotate `dst` before blitting.
      NOTE: unlike `SDL_RenderCopyEx`, `angle` here is in radians.
    * center - the center to rotate `angle` radians around. If nil or omitted,
      the center of mass of the rectangle is assumed.
    * flipX - if true, the image will be flipped horizontally when blit on
      the render target
    * flipY - if true, the image will be flipped vertically when blit on
      the render target
    """

  def isStreaming() Bool:
    """
    Returns true if this is a streaming texture.
    """

  def update() nil:
    """
    If this `Texture` was created with the `streaming` parameter
    set to true, this method will update the texture to the
    current state of the associated `Image`.

    Otherwise, this method raises an error.
    """


class Geometry:
  """
  One of the two primary mechanisms used for rendering graphics on the screen.
  (the other mechanism being `Canvas` - for drawing text, HUD, and other
  kind of rendering that does not require a notion of 'space')

  A Geometry is a list of vertices and indices into those vertices
  that describes a set of triangles that can be rendered.

  Each vertex can be set to a specific color to create gradient images.

  Almost everything about a geometry can be modified through its methods
  except for the number of vertices and indices it has.
  """

  final transform Matrix """
    The transformation matrix for this geometry.
    Usually initialized to the identity matrix.
  """

  def blit() nil:
    """
    Draw this `Geometry` to the associated window

    This function is more or less a wrapper of `SDL_RenderGeometry`
    """

  def setTexture(texture Texture?) nil:
    """
    Assigns a texture to this geometry.
    A `nil` value will remove the prior texture associated with this
    geometry, if any.
    """

  def setColor(color Color) nil:
    """
    Set the color of all vertices of this Geometry to the given color
    """

  def getVertexCount() Int:
    """
    Returns the number of vertices in this geometry
    """

  def setVertexColor(i Int, color Color) nil:
    """
    Sets the color of the vertex specified by `i`.
    """

  def setVertexTextureCoordinates(i Int, coords Vector) nil:
    """
    Sets the (normalized) texture coordinates of the vertex specified by `i`.
    """

  def setVertexPosition(i Int, position Vector) nil:
    """
    Sets the position of the vertex specified by `i`.

    NOTE: the position specified is not the final position used to draw the location
    on the screen. The given position will be modified by the transform matrices of
    both the geometry and the window.
    """

  def getIndexCount() Int:
    """
    Returns the number of indices in this geometry
    """

  def setIndex(j Int, index Int) nil:
    """
    Sets the index specified by `j` to the value `index`.

    `index` should be an index into the list of vertices.
    """


class ClickEvent:
  """
  Click events fire when a mouse clicks or a finger touches a
  part of the window or screen (onClick and onClickUp).
  """

  final x Int "x coordinate, relative to the window"
  final y Int "y coordinate, relative to the window"
  final button Int """
    The button that was pressed.
    1 - left mouse button,
    2 - middle mouse button,
    3 - right mouse button
  """


class MotionEvent:
  """
  Motion events fire when the mouse or touch moves across the window
  """

  final x Int "x coordinate relative to the window"
  final y Int "y coordinate relative to the window"
  final dx Int "relative motion in the x direction"
  final dy Int "relative motion in the y direction"


def key(scancode Int, query Int=0, repeat Bool=true) Bool:
  """
  Queries the state of a key on the keyboard

  Parameters:
  * scancode - a non-negative integer that specifies the key on the keyboard.
    You can get these by name from the `gg.KEY` dictionary.

    These values come from the USB HID Keyboard scan codes as per USB spec.

    For more information, see:
      * https://stackoverflow.com/q/27075328
      * https://source.android.com/docs/core/interaction/input/keyboard-devices

  * query - an integer between 0-2 inclusive indicating the kind of
    event to query for.
    Defaults to 0.
    * 0 (PRESSED) - tests whether a keypress event for the given key was
      emitted within the last frame.
    * 1 (RELEASED) - tests whether a release event was emitted for the given
      key within the last frame.
    * 2 (HELD) - test whether the key is currently being held down by
      the player.

  * repeat - indicates whether or not repeat keydown events count.
  """


def getKey(type Int = 0) Int:
  """
  Pops a key that has been pressed or released within the last frame.
  If there are no keys left in the stack, returns `-1`.

  Parameters:
  * type - if 0 (the default), `getKey` will look for a key that was pressed.
    If 1, `getKey` will look for a key that was released.
  """


def mousePosition() Vector:
  """
  Retrieves the current mouse position relative to the window
  """


def mouseButton(buttonID Int, query Int=0) Bool:
  """
  Queries the state of a mouse button.

  Parameters:
  * mouseButtonID - an integer between 0-2 inclusive indicating the mouse button.
    Defaults to 0.
    * 0 (LEFT) - the left mouse button
    * 1 (RIGHT) - the right mouse button
    * 2 (MIDDLE) - the middle mouse button
  * query - an integer between 0-2 inclusive indicating the kind of button
    event to query for.
    Defaults to 0.
    * 0 (PRESSED) - tests for whether the given button was just clicked
      within the past frame.
    * 1 (RELEASED) - tests whether the given button was just released within
      the past frame.
    * 2 (HELD) - test whether the button is currently being held down by
      the player.
  """


def loadAudio(audio Audio, channel Int=0) nil:
  """
  Load audio to play.

  There are 8 channels, and the audio will be loaded to the given channel
  """


def playAudio(channel Int=0, repeats Int=0) nil:
  """
  Play audio in the given channel

  `repeats` argument may be set to have the audio play an extra `repeat` times.
  Negative value will cause audio to loop I32_MAX times.
  """


def pauseAudio(channel Int=0, pause Bool=true) nil:
  """
  Pauses the audio
  """


def setAudioVolume(channel Int, volume Int) nil:
  """
  Sets the volume for a given audio channel.

  The volume must be between 0 and 128 inclusive.
  """
