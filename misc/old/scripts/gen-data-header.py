"""
Given some binary data, generate a C header that contains that binary data.
"""

import argparse
from typing import List

aparser = argparse.ArgumentParser()
aparser.add_argument('--output', '-o', required=True)
aparser.add_argument('--input', '-i', required=True)
aparser.add_argument('--variable-name', '-v', required=True)
aparser.add_argument('--length-name', '-l', required=True)
args = aparser.parse_args()

OFILE: str = args.output
IFILE: str = args.input
VNAME: str = args.variable_name
LNAME: str = args.length_name

print(f"OFILE {OFILE!r}")
print(f"IFILE {IFILE!r}")
print(f"VNAME {VNAME!r}")
print(f"LNAME {LNAME!r}")

lastWasOctal = False
data: List[str] = []
pack: List[int] = []


# def flush():
#     while len(pack) < 2:
#         pack.append(0)
#     value = int.from_bytes(bytes(pack), 'little')
#     data.append(str(value))

#     # asHex = hex(value)
#     # asDec = str(value)
#     # # According to:
#     # # https://en.cppreference.com/w/cpp/language/integer_literal
#     # # Decimal literals are always assumed to be signed, and so
#     # # if long is 32-bit, the literal value might not fit if it is
#     # # too big.
#     # # On the other hand, if it is in hex, the standard requires
#     # # the compiler try unsigned long.
#     # # So if there is a tie, we prefer hex (at i32 max, hex (including the
#     # # 0x prefix) and decimal representations are tied)
#     # data.append(asHex if len(asHex) <= len(asDec) else asDec)
#     pack.clear()


with open(IFILE, 'rb') as f:
    for byte in f.read():
        data.append(str(byte))

with open(OFILE, 'wb') as f:
    f.write(f"""
/*
 * AUTOGENERATED FILE {OFILE}
 * (autogenerated by gen-data-header.py)
 *
 * python3 scripts/gen-data-header.py
 *   -o {OFILE}
 *   -i {IFILE}
 *   -v {VNAME}
 *   -l {LNAME}
 */

#define {LNAME} {len(data)}

static const unsigned char {VNAME}[] = {{ {','.join(data)} }};

""".encode())
